1. В задании явным образом прописано, что, как и ранее, результат работы следует оформлять в виде статической библиотеки s21_containers.a.
Однако в данном проекте необходимо использовать шаблоны функций и классов.
А ввиду того, что генерация конкретной шаблонной функции происходит только в момент компиляции, то получается], что нам необходимо заранее явно перечислить компилятору все типы для генерации соответствующих шаблонов.
Это, по понятным причинам, сделать невозможно. Кроме того пользователь может создать свои классы и использовать их для хранения в наших контейнерах.

2. В STL нет метода begincbegin – это опечатка в тексте задания? Подразумеваются методы begin И cbegin? С endcend аналогично.
Касается всех контейнеров, в которых присутствует описание и функционал интераторов.

3. В спецификации для stack указан конструктор , принимающий количество узлов, под которые выделяется память при создании объекта. В STL для stack такого конструктора нет по причине его бесполезности. Зачем нам создавать пустые элементы стека, если push все равно происходит в конец стека? К тому же эти пустые элементы не несут никакой информации , так как итераторов в стеке нет и изменить их никак нельзя.

4. В спецификации для set указаны три метода insert, из которых два последних (insert(Key, Value) и insert_or_assign(Key, Value)) относятся к map, т.к. требуется вставить пару элементов ключ-значение. В multiset также присутствует один лишний метод, относящийся к map.

5. Во второй бонусной части первый метод emplace не может быть грамотно имплементирован в multiset! Структура двоичного дерева не предоставляет пользователю возможности произвольной вставки элемента, т.к. данные в ней всегда должны быть строго упорядочены. В оригинальной STL даже нельзя менять содержимое элементов при разыменовывании итераторов ассоциативных контейнеров.

6. Для контейнеров, поддерживающих функционал итераторов, указаны определения типов, которые просто не могут вязаться с реальной реализацией. Разве может итератор иметь тип, скажем, указателя на int, когда я хочу иметь доступ как к предыдущему, так и к следующему элементам? Например, в случае ассоциативных контейнеров итераторы имеют тип указателя на узел двоичного дерева поиска. А можно вообще реализовать итераторы не через typedef и перегрузку операций, а через вложенные классы, что было бы тоже довольно понятно и логично. Поэтому эта формулировка требует уточнения.

7. Для класса array его размер должен быть известен во время компиляции, т.к. в последствии изменять его нельзя. Поэтому в STL размер array указывается прям в аргументах шаблона в виде
std::array<int, 5> a1 = {1, 2, 3};
Однако в описанной спецификации присутствует конструктор, который ломает логику этого поведения. Этот конструктор принимает единственный аргумент – собственно размер массива, который уже есть в аргументах шаблона и в отдельном определении не нуждается. Этого конструктора не должно быть для класса array.

8. (дополнение к 5 пункту)
Во второй бонусной части также требуется реализовать метод emplace для map и set, который возвращает std::pair. В случае insert все ясно – pair содержит итератор, указывающий на элемент, который был вставлен (либо уже существовал), и bool переменную, отображающую был ли вставлен новый элемент.
В случае emplace, может быть вставлено неограниченное количество элементов, соответственно, один pair не может содержать информацию по всем вставленным элементам. Здесь имеет смысл возвращать либо
vector<std::pair<iterator, bool>>
либо просто количество успешно вставленных элементов (size_t), либо вообще ничего (void).
